const axios = require('axios');
const express = require('express');
const line = require('@line/bot-sdk');
const firebase = require('firebase-admin');

// --- 1. Áí∞Â¢ÉËÆäÊï∏Ë®≠ÂÆö ---
const config = {
  channelAccessToken: process.env.CHANNEL_ACCESS_TOKEN || 'YOUR_CHANNEL_ACCESS_TOKEN',
  channelSecret: process.env.CHANNEL_SECRET || 'YOUR_CHANNEL_SECRET',
};

let serviceAccount;
try {
  if (process.env.FIREBASE_SERVICE_ACCOUNT) {
    serviceAccount = JSON.parse(process.env.FIREBASE_SERVICE_ACCOUNT);
  } else {
    console.warn('Firebase service account key not found. Local development might fail.');
  }
} catch (e) {
  console.error('Failed to parse Firebase service account key:', e);
}

// --- 2. ÂàùÂßãÂåñÊúçÂãô ---
const app = express();
const client = new line.Client(config);
let db;

if (serviceAccount) {
  firebase.initializeApp({
    credential: firebase.credential.cert(serviceAccount)
  });
  db = firebase.firestore();
  console.log('Firebase Admin SDK initialized successfully.');
} else {
  console.error('Firebase Admin SDK initialization failed.');
}

const taipeiDistricts = ["‰∏≠Ê≠£ÂçÄ", "Â§ßÂêåÂçÄ", "‰∏≠Â±±ÂçÄ", "ÊùæÂ±±ÂçÄ", "Â§ßÂÆâÂçÄ", "Ëê¨ËèØÂçÄ", "‰ø°Áæ©ÂçÄ", "Â£´ÊûóÂçÄ", "ÂåóÊäïÂçÄ", "ÂÖßÊπñÂçÄ", "ÂçóÊ∏ØÂçÄ", "ÊñáÂ±±ÂçÄ"];

// --- 3. Webhook Ë∑ØÁî± ---
app.post('/webhook', line.middleware(config), (req, res) => {
  Promise
    .all(req.body.events.map(handleEvent))
    .then((result) => res.json(result))
    .catch((err) => {
      console.error('Webhook Error:', err);
      res.status(500).end();
    });
});

// --- 4. ‰∫ã‰ª∂ËôïÁêÜÈÇèËºØ ---
async function handleEvent(event) {
  // Handle non-message events first
  if (event.type !== 'message') {
    return Promise.resolve(null);
  }

  const userId = event.source.userId;
  const sessionRef = db.collection('user_sessions').doc(userId);

  // Handle Location Message
  if (event.message.type === 'location') {
    const { latitude, longitude } = event.message;
    const district = await getDistrictFromCoordinates(latitude, longitude);

    if (district && taipeiDistricts.includes(district)) {
      await sessionRef.set({
        stage: 'location_received',
        latitude,
        longitude,
        district,
        createdAt: new Date()
      });
      const reply = {
        type: 'text',
        text: `ÊÇ®ÁõÆÂâçÂú®„Äå${district}„ÄçÔºåË¶ÅÁÇ∫ÊÇ®Êé®Ëñ¶ÈôÑËøëÁöÑÂ∫óÂÆ∂ÂóéÔºü`,
        quickReply: {
          items: [{
            type: 'action',
            action: { type: 'message', label: 'Êé®Ëñ¶ÈôÑËøëÂ∫óÂÆ∂', text: 'Êé®Ëñ¶ÈôÑËøëÂ∫óÂÆ∂' }
          }]
        }
      };
      return client.replyMessage(event.replyToken, reply);
    } else {
      const reply = { type: 'text', text: 'Êä±Ê≠âÔºåÊÇ®ÁõÆÂâçÁöÑ‰ΩçÁΩÆ‰ºº‰πé‰∏çÂú®Âè∞ÂåóÂ∏ÇÁØÑÂúçÂÖßÂñî„ÄÇ' };
      return client.replyMessage(event.replyToken, reply);
    }
  }

  // Handle Text Messages
  if (event.message.type === 'text') {
    const receivedText = event.message.text.trim();
    const sessionDoc = await sessionRef.get();
    const selectionState = sessionDoc.exists ? sessionDoc.data() : null;

    // Handle "Êé®Ëñ¶ÈôÑËøëÂ∫óÂÆ∂" button
    if (receivedText === 'Êé®Ëñ¶ÈôÑËøëÂ∫óÂÆ∂' && selectionState && selectionState.stage === 'location_received') {
      const { latitude, longitude } = selectionState;
      await sessionRef.delete(); // Clean up session
      return performNearbyRecommendation(event.replyToken, latitude, longitude);
    }

    // Handle "Use current location" button
    if (receivedText === 'üìç ‰ΩøÁî®ÁõÆÂâç‰ΩçÁΩÆÊé®Ëñ¶') {
        const reply = { type: 'text', text: 'Â•ΩÁöÑÔºåË´ãÈªûÊìäÁï´Èù¢Â∑¶‰∏ãËßíÁöÑ„Äå+„ÄçËôüÔºåÈÅ∏Êìá„Äå‰ΩçÁΩÆË≥áË®ä„ÄçÔºå‰∏¶ÂàÜ‰∫´ÊÇ®ÁöÑ‰ΩçÁΩÆÁµ¶Êàë„ÄÇ' };
        return client.replyMessage(event.replyToken, reply);
    }

    // Handle "Êé®Ëñ¶" flow
    if (receivedText === 'Êé®Ëñ¶') {
      await sessionRef.set({ stage: 'selecting_district', createdAt: new Date() });
      
      const districtItems = taipeiDistricts.map(district => ({
          type: 'action',
          action: { type: 'message', label: district, text: district }
      }));

      const locationItem = {
          type: 'action',
          action: { type: 'message', label: 'üìç ‰ΩøÁî®ÁõÆÂâç‰ΩçÁΩÆÊé®Ëñ¶', text: 'üìç ‰ΩøÁî®ÁõÆÂâç‰ΩçÁΩÆÊé®Ëñ¶' }
      };

      const reply = {
        type: 'text',
        text: 'Ë´ãÈÅ∏ÊìáÊÇ®ÊÉ≥Êé¢Á¥¢ÁöÑÂè∞ÂåóÂ∏ÇË°åÊîøÂçÄÔºåÊàñ‰ΩøÁî®ÊÇ®ÁõÆÂâçÁöÑ‰ΩçÁΩÆÔºö',
        quickReply: {
          items: [locationItem, ...districtItems].slice(0, 13)
        }
      };
      return client.replyMessage(event.replyToken, reply);
    }

    // Handle district selection in interactive flow
    if (selectionState && selectionState.stage === 'selecting_district' && taipeiDistricts.includes(receivedText)) {
      await sessionRef.update({ stage: 'selecting_category', district: receivedText });
      const categories = ['ÂíñÂï°Âª≥', 'È§êÂª≥', 'ÊôØÈªû', 'ÊâÄÊúâÂ∫óÂÆ∂'];
      const reply = {
        type: 'text',
        text: `ÊÇ®ÈÅ∏‰∫Ü„Äå${receivedText}„Äç„ÄÇÊÉ≥Êâæ‰ªÄÈ∫ºÊ®£ÁöÑÂàÜÈ°ûÂë¢Ôºü`,
        quickReply: {
          items: categories.map(category => ({
            type: 'action',
            action: {
              type: 'message',
              label: category,
              text: category
            }
          }))
        }
      };
      return client.replyMessage(event.replyToken, reply);
    }

    // Handle category selection and provide recommendations in interactive flow
    if (selectionState && selectionState.stage === 'selecting_category') {
      const district = selectionState.district;
      const categoryInput = receivedText;
      const validCategories = ['ÂíñÂï°Âª≥', 'È§êÂª≥', 'ÊôØÈªû', 'ÊâÄÊúâÂ∫óÂÆ∂'];

      if (validCategories.includes(categoryInput)) {
        const category = categoryInput === 'ÊâÄÊúâÂ∫óÂÆ∂' ? null : categoryInput;
        await sessionRef.delete(); // End of flow
        return performRecommendation(event.replyToken, district, category);
      }
    }

    // All other messages will fall through to here.
    // Guide the user to start the recommendation flow.
    const reply = { type: 'text', text: `ÊÇ®Â•ΩÔºÅË´ãË©¶ËëóÂÇ≥ÈÄÅ„ÄåÊé®Ëñ¶„ÄçÔºåËÆìÊàëÁÇ∫ÊÇ®Â∞ãÊâæÂè∞ÂåóÂ∏ÇÁöÑÂ•ΩÂéªËôïÔºÅ` };
    return client.replyMessage(event.replyToken, reply);
  }

  return Promise.resolve(null);
}

// Helper function to perform recommendation and reply
async function performRecommendation(replyToken, district, category) {
  try {
    const stores = await getRecommendations(district, category);
    if (!stores || stores.length === 0) {
      const reply = { type: 'text', text: `Êä±Ê≠âÔºåÂú®„Äå${district}„Äç${category ? `ÁöÑ„Äå${category}„ÄçÂàÜÈ°û‰∏≠` : ''}Êâæ‰∏çÂà∞ÂèØÊé®Ëñ¶ÁöÑÂ∫óÂÆ∂„ÄÇ` };
      return client.replyMessage(replyToken, reply);
    }
    const reply = createStoreCarousel(stores, district, category);
    return client.replyMessage(replyToken, reply);
  } catch (error) {
    console.error("Recommendation Error:", error);
    const reply = { type: 'text', text: 'ÂìéÂëÄÔºåÊé®Ëñ¶ÂäüËÉΩÂ•ΩÂÉèÂá∫‰∫Ü‰∏ÄÈªûÂïèÈ°åÔºåË´ãÁ®çÂæåÂÜçË©¶„ÄÇ' };
    return client.replyMessage(replyToken, reply);
  }
}

// New Helper: Perform nearby recommendation and reply
async function performNearbyRecommendation(replyToken, latitude, longitude) {
    try {
        const stores = await getNearbyRecommendations(latitude, longitude);
        if (!stores || stores.length === 0) {
            const reply = { type: 'text', text: `Êä±Ê≠âÔºåÂú®ÊÇ®ÈôÑËøëÊâæ‰∏çÂà∞ÂèØÊé®Ëñ¶ÁöÑÂ∫óÂÆ∂„ÄÇ` };
            return client.replyMessage(replyToken, reply);
        }
        const reply = createStoreCarousel(stores, 'ÊÇ®ÈôÑËøë');
        return client.replyMessage(replyToken, reply);
    } catch (error) {
        console.error("Nearby Recommendation Error:", error);
        const reply = { type: 'text', text: 'ÂìéÂëÄÔºåÊé®Ëñ¶ÈôÑËøëÂ∫óÂÆ∂ÂäüËÉΩÂ•ΩÂÉèÂá∫‰∫Ü‰∏ÄÈªûÂïèÈ°åÔºåË´ãÁ®çÂæåÂÜçË©¶„ÄÇ' };
        return client.replyMessage(replyToken, reply);
    }
}


// --- 5. Ê†∏ÂøÉÊé®Ëñ¶ÈÇèËºØ ---

// New Helper: Get district from coordinates using Google Geocoding API
async function getDistrictFromCoordinates(latitude, longitude) {
    const apiKey = process.env.GOOGLE_MAPS_API_KEY;
    if (!apiKey) {
        console.error('Google Maps API key is not set.');
        return null;
    }
    const url = `https://maps.googleapis.com/maps/api/geocode/json?latlng=${latitude},${longitude}&key=${apiKey}&language=zh-TW`;

    try {
        const response = await axios.get(url);
        const data = response.data;

        if (data.status !== 'OK') {
            console.error(`Google Geocoding API returned status: ${data.status}. Response: ${JSON.stringify(data)}`);
        }

        if (data.status === 'OK' && data.results.length > 0) {
            const addressComponents = data.results[0].address_components;
            const cityComponent = addressComponents.find(c => c.types.includes('administrative_area_level_2'));
            const districtComponent = addressComponents.find(c => c.types.includes('administrative_area_level_3') || c.types.includes('sublocality_level_1'));

            if (cityComponent && cityComponent.long_name === 'Âè∞ÂåóÂ∏Ç' && districtComponent && taipeiDistricts.includes(districtComponent.long_name)) {
                return districtComponent.long_name;
            }
        }
        return null;
    } catch (error) {
        console.error('Google Geocoding API error:', error.response ? JSON.stringify(error.response.data) : error.message);
        return null;
    }
}

// New Helper: Calculate distance between two coordinates (Haversine formula)
function calculateDistance(lat1, lon1, lat2, lon2) {
    if ((lat1 == lat2) && (lon1 == lon2)) {
        return 0;
    }
    const R = 6371; // Radius of the Earth in km
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
}

// New Helper: Get nearby recommendations
async function getNearbyRecommendations(latitude, longitude) {
    if (!db) throw new Error('Firestore is not initialized.');

    const district = await getDistrictFromCoordinates(latitude, longitude);
    if (!district) return [];

    const snapshot = await db.collection('stores_taipei').where('district', '==', district).get();
    if (snapshot.empty) {
        return [];
    }

    const storesInDistrict = [];
    snapshot.forEach(doc => {
        const data = doc.data();
        // Assuming store data has latitude and longitude fields
        if (data.latitude && data.longitude) {
            storesInDistrict.push({ id: doc.id, ...data });
        }
    });

    if (storesInDistrict.length === 0) return [];

    // Calculate distance for each store
    const storesWithDistance = storesInDistrict.map(store => {
        const distance = calculateDistance(latitude, longitude, store.latitude, store.longitude);
        return { ...store, distance };
    });

    // Sort by distance and take the top 3
    storesWithDistance.sort((a, b) => a.distance - b.distance);
    return storesWithDistance.slice(0, 3);
}

function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
}

async function getRecommendations(district, category) {
    if (!db) throw new Error('Firestore is not initialized.');

    const snapshot = await db.collection('stores_taipei').where('district', '==', district).get();
    if (snapshot.empty) {
        return [];
    }

    const allStoresInDistrict = [];
    snapshot.forEach(doc => allStoresInDistrict.push({ id: doc.id, ...doc.data() }));


    let randomStores = [];
    const numToRecommend = 3;

    if (category) {
        let storesInCategory = allStoresInDistrict.filter(s => s.category === category);
        let storesInOtherCategories = allStoresInDistrict.filter(s => s.category !== category);
        shuffleArray(storesInCategory);
        shuffleArray(storesInOtherCategories);

        const takeFromCategory = Math.min(storesInCategory.length, numToRecommend);
        randomStores = storesInCategory.slice(0, takeFromCategory);

        const remainingNeeded = numToRecommend - randomStores.length;
        if (remainingNeeded > 0 && storesInOtherCategories.length > 0) {
            const takeFromOthers = Math.min(remainingNeeded, storesInOtherCategories.length);
            randomStores.push(...storesInOtherCategories.slice(0, takeFromOthers));
        }
    } else {
        shuffleArray(allStoresInDistrict);
        randomStores = allStoresInDistrict.slice(0, numToRecommend);
    }

    return randomStores;
}

// --- 6. Áî¢Áîü LINE Flex Message ---
function createStoreCarousel(stores, district, category) {
    const bubbles = stores.map(store => {
        const bodyContents = [
            {
                type: 'box',
                layout: 'baseline',
                spacing: 'sm',
                contents: [
                    { type: 'text', text: 'Âú∞ÂùÄ', color: '#aaaaaa', size: 'sm', flex: 1 },
                    { type: 'text', text: store.address || 'Êú™Êèê‰æõ',
                      wrap: true, color: '#666666', size: 'sm', flex: 3 }
                ]
            }
        ];

        if (store.dishes) {
            bodyContents.push({
                type: 'box',
                layout: 'baseline',
                spacing: 'sm',
                margin: 'md',
                contents: [
                    { type: 'text', text: 'ËèúËâ≤', color: '#aaaaaa', size: 'sm', flex: 1 },
                    { type: 'text', text: store.dishes, wrap: true, color: '#666666', size: 'sm', flex: 3 }
                ]
            });
        }

        return {
            type: 'bubble',
            size: 'kilo',
            header: {
                type: 'box',
                layout: 'vertical',
                contents: [
                    {
                        type: 'text',
                        text: store.name || 'Â∫óÂÆ∂ÂêçÁ®±',
                        weight: 'bold',
                        size: 'lg',
                        wrap: true,
                    },
                    {
                        type: 'text',
                        text: store.category || 'Êú™ÂàÜÈ°û',
                        size: 'md',
                        color: '#666666',
                        wrap: true,
                        margin: 'md'
                    }
                ]
            },
            body: {
                type: 'box',
                layout: 'vertical',
                contents: bodyContents
            },
            footer: {
                type: 'box',
                layout: 'vertical',
                spacing: 'sm',
                contents: [
                    {
                        type: 'button',
                        style: 'link',
                        height: 'sm',
                        action: {
                            type: 'uri',
                            label: 'Âú® Google Âú∞Âúñ‰∏äÊü•Áúã',
                            uri: `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(store.address || store.name)}`
                        }
                    }
                ]
            }
        };
    });

    return {
        type: 'flex',
        altText: `ÁÇ∫ÊÇ®Âæû„Äå${district}„ÄçÊé®Ëñ¶‰∫Ü ${stores.length} ÈñìÂ∫óÔºÅ`,
        contents: {
            type: 'carousel',
            contents: bubbles
        }
    };
}

// --- 7. ÂïüÂãï‰º∫ÊúçÂô® ---
const port = process.env.PORT || 3000;
app.listen(port, () => {
  console.log(`Server is running on port ${port}`);
});
